<?xml version="1.0" encoding="UTF-8"?>
<item><pubDate>Fri, 13 Feb 2015 11:03:09 +0100</pubDate><title><![CDATA[Case 5 - Inheritance &amp; Scoping]]></title><url><![CDATA[case-5-prototyping]]></url><meta><![CDATA[]]></meta><metad><![CDATA[]]></metad><menu><![CDATA[Case 5 - Inheritance &amp; Scoping]]></menu><menuOrder><![CDATA[11]]></menuOrder><menuStatus><![CDATA[Y]]></menuStatus><template><![CDATA[template.php]]></template><parent><![CDATA[]]></parent><content><![CDATA[&lt;h2&gt;Source&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;data/uploads/case5.zip&quot;&gt;Download de source&lt;/a&gt; voor deze opdracht om te beginnen met de case. Pak de zip file uit zoals je in case 1 hebt geleerd. Als het goed is zie je nu in WebStorm onder de folder &quot;opdrachten&quot; de sources van case 5 staan.&lt;br /&gt;
	&lt;a href=&quot;data/uploads/case5_inheritance_scoping.pdf&quot;&gt;Presentatie in PDF&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Omschrijving&lt;/h2&gt;
&lt;p&gt;Zojuist is verteld hoe je inheritance via prototyping werkt in javascript en in welke scope objecten zitten die je aanmaakt. Tevens is je net uitgelegd hoe het module pattern werkt. Het doel van deze opdracht is het leren van omgaan met inheritence van objecten middels prototyping. Tevens leer je in deze opdracht hoe je ervoor zorgt dat niet alle objecten die je maakt in de global scope terecht komen.&lt;/p&gt;
&lt;p&gt;Voer voor het uitvoeren van de opdracht het de commando&#039;s &quot;npm install&quot; en &quot;grunt watch&quot; uit. Zorg ervoor dat er gedurende de opdracht geen fouten van grunt op de console verschijnen. Je mag ook, i.p.v. het commando &quot;grunt watch&quot; na het uitvoeren van de opdrachten het &quot;grunt&quot; commando draaien, ook hierbij geldt, zorg ervoor dat grunt geen fouten aangeeft.&lt;/p&gt;
&lt;h2&gt;Opdracht 1 - Inheritance via prototyping&lt;/h2&gt;
&lt;p&gt;Open in je browser de URL &quot;http://localhost:8000/opdrachten/case5/template.html&quot; om de zesde case te laden. Je ziet het todoscherm van de applicatie voor je.&lt;/p&gt;
&lt;p&gt;Bekijk in WebStorm de javascript bestanden die bij deze opdracht horen. Doorloop onderstaande stappen om de opdracht te voltooien.&lt;/p&gt;
&lt;h3&gt;Inheritance&lt;/h3&gt;
&lt;ol&gt;
	&lt;li&gt;De bedoeling is dat we aan de TodoView class standaard logfunctionaliteiten gaan gebruiken die in de View class is gedeclareerd. Zorg ervoor dat de TodoView class de View class extend.&lt;/li&gt;
	&lt;li&gt;Refresh in je browser de pagina en gebruik FireBug om de todoViewInstance die in init.js gemaakt wordt op de console te loggen. Als het goed is geeft FireBug aan dat de todoViewInstance een constructor heeft &quot;TodoView&quot; en 3 methodes; renderTodos, renderGebruikers en logVariable.&lt;/li&gt;
	&lt;li&gt;Voer in FireBug een instanceof check uit van de todoViewInstance tegen View en tegen TodoView. Als het goed is leveren beide resultaten true op. Als dit niet zo is, heb je de prototype chain in stap 1 niet goed opgezet.&lt;/li&gt;
	&lt;li&gt;Zorg in de renderTodos en renderGebruikers methodes ervoor dat als eerste regel in die methodes de logVariable methode wordt aangeroepen op de this instance. Geef aan de methode de gebruikers/todos waarmee dus de inputvariabele van de methode worden gelogd.&lt;/li&gt;
	&lt;li&gt;Refresh in je browser de pagina. Controleer of er twee logregels op de FireBug console verschijnen. Als het goed is zie je twee logregels met 1 maal de gebruikers array als JSON en 1 maal de todos array als JSON gelogged. De prefix is echter nu nog &quot;undefined&quot;, hoe kan dit? Waar komt deze prefix vandaan? Los dit probleem op door een aanpassing te maken in de TodoView class, gebruik als prefix &quot;TodoView&quot;.&lt;/li&gt;
	&lt;li&gt;Refresh nogmaals de browser, als je stap 5 goed hebt gedaan zie je nu &quot;TodoView&quot; als prefix voor de logregel.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Overriden methods&lt;/h3&gt;
&lt;ol start=&quot;7&quot;&gt;
	&lt;li&gt;Alle logregels die vanuit de TodoView gelogd worden, dienen nu tevens de lengte van de Array te loggen. Om dit te bewerkstelligen moet je de logVariable methode overriden in de TodoView. Doe dit, en zorg er tevens voor dat de logVariable methode uit de View class (de parent of superclass) wordt aangeroepen. Voer daarna het tweede log statement uit in de overridden methode. Het aantal element van een Array kun je opvragen via de &quot;length&quot; property. Als je de browser refreshed dien je in de console log van je browser het volgende te zien:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;tt&gt;&lt;em&gt;TodoView - {&quot;id&quot;:1,&quot;titel&quot;:&quot;Afmaken opdracht 1&quot;,...&lt;br /&gt;
	Aantal items gerenderd: 2&lt;/em&gt;&lt;br /&gt;
	&lt;em&gt;TodoView - {&quot;id&quot;:1,&quot;naam&quot;:&quot;J. Script&quot;,&quot;gebruikersnaam&quot;:&quot;jscript&quot;...&lt;br /&gt;
	Aantal items gerenderd: 3&lt;/em&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;h2&gt;Opdracht 2 - Scoping&lt;/h2&gt;
&lt;p&gt;Als je de javascript bestanden van case 5 bekijkt, dan zie je dat er een aantal zaken worden gedeclareerd, zoals: todos, gebruikers, todoViewInstance, maar ook classes als; TodoView en View. Je hebt je misschien al afgevraagd wat er gebeurd als je nogmaals variabelen declareert als &quot;todos&quot; of &quot;gebruikers&quot;. Tevens heb je je misschien afgevraagd wat er gebeurd als je nog een &quot;TodoView&quot; declareert.&lt;/p&gt;
&lt;p&gt;Als je geluk hebt bij het dubbel declareren van instance variabelen en classes krijg je een TypeError in je console, als je pech hebt lijkt alles nog te werken zoals het hoort, totdat je tegen een uithoek van je applicatie aanloopt en je vreemd gedrag en javascript errors krijgt. Volg onderstaande stappen om de opdracht uit te voeren:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Probeer in init.js bovenaan nogmaals een constructor function genaamd TodoView te declareren. Refresh vervolgens je browser, wat gebeurd er? Hoe komt dit?&lt;/li&gt;
	&lt;li&gt;Haal de net gemaakt constructor function weer weg, refresh je browser en verifieer of de pagina weer werkt. Voer middels FireBug een console.log uit van de variable &quot;todoViewInstance&quot; en van &quot;window.todoViewInstance&quot;. Wat valt je op? Welke conclusie kun je hieruit voorzichtig trekken? Voer een === vergelijking tussen de twee uit om dit te verifieren.&lt;/li&gt;
	&lt;li&gt;Herhaal stap 2 met de variabele &quot;gebruikers&quot;. Herhaal stap 2 vervolgens met de classes &quot;View&quot; en &quot;TodoView&quot;. Wat valt je op?&lt;/li&gt;
	&lt;li&gt;Op welke manier kunnen we dit probleem van scoping oplossen, dus hoe zorg je ervoor dat niet alles binnen de global scope zit?&lt;/li&gt;
	&lt;li&gt;Pas het module pattern toe en zorg ervoor dat je een DataModule en een ViewModule maakt. Zorg er voor dat de applicatie na de aanpasingen blijft werken door een refresh te geven in je browser en te controleren dat er geen javascript errors meer optreden.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Tips bij stap 5:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Voor deze opdracht is het voldoende om alle code die in 1 module hoort, ook in 1 file/bestand te plaatsen. Vergeet het template hier niet op aan te passen.&lt;/li&gt;
	&lt;li&gt;Denk goed na over de publieke API van de modules. Niet alle interne code hoeft van buiten de module benaderbaar te zijn.&lt;/li&gt;
	&lt;li&gt;Als je de opdracht goed hebt uitgevoerd, zijn alleen module variabelen en de publieke API&#039;s van de modules die hebt gemaakt beschikbaar in de global scope. Zo zal de View class, TodoView class en de todoViewInstance in de init.js niet meer beschikbaar moeten zijn in de global scope. Toon dit aan/controleer door stap 2 te herhalen. De View class zou je helemaal niet meer moeten kunnen achterhalen middels FireBug.&lt;/li&gt;
&lt;/ul&gt;
]]></content><private><![CDATA[]]></private><author><![CDATA[jsadmin]]></author></item>
