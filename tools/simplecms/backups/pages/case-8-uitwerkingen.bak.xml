<?xml version="1.0" encoding="UTF-8"?>
<item><pubDate>Thu, 06 Mar 2014 14:57:02 +0100</pubDate><title><![CDATA[Case 8 - Uitwerkingen]]></title><url><![CDATA[case-8-uitwerkingen]]></url><meta><![CDATA[]]></meta><metad><![CDATA[]]></metad><menu><![CDATA[Case 8 - Uitwerkingen]]></menu><menuOrder><![CDATA[16]]></menuOrder><menuStatus><![CDATA[Y]]></menuStatus><template><![CDATA[template.php]]></template><parent><![CDATA[case-8-amd]]></parent><content><![CDATA[&lt;p&gt;&lt;a href=&quot;data/uploads/case8-uitwerkingen.zip&quot;&gt;Download de sources van de uitwerking&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1. Blader door de verschillende javascript sources en de js/app folders. Probeer te begrijpen wat de functionaliteiten van de verschillende files zijn. Wat valt je op over de opzet van de applicatie? Welk pattern wordt er toegepast?&lt;/h3&gt;
&lt;p&gt;De applicatie is opgezet volgens het MV*(VM/C/P/W) pattern. De view is verantwoordelijk voor het uiteindelijke renderen van Todo en Gebruiker instanties. In de view ligt dan ook de logica om met de DOM om te gaan. De controllers zijn verantwoordelijk voor het aansturen van de view. Zo vind bijvoorbeeld het afhandelen van websocket events op de controllers plaats. Als laatste zijn er nog de Storage instanties, die zorgen voor communicatie met de &quot;backend&quot;, in dit geval de REST service die voor de daadwerkelijke opslag zorgt.&lt;/p&gt;
&lt;p&gt;Het javascript pattern wat werd toegepast toen je begon met de applicatie is het module pattern, wat je in case 6 geleerd hebt.&lt;/p&gt;
&lt;h3&gt;2. Open vervolgens het bestand &quot;template.html&quot;. Wat valt je op/welk nadeel kun je herkennen aan de huidige opzet?&lt;/h3&gt;
&lt;p&gt;Het bestand template.html bevat nu alle modules die binnen de applicatie bekend zijn. Deze zijn te vinden in de &amp;lt;script&amp;gt; tags onderaan de pagina. Als er nieuwe modules bijkomen, of de modulenaam zou veranderen, dan zal dit template.html bestand moeten worden aangepast. Tevens zal er altijd gezorgd moeten worden dat de &amp;lt;script&amp;gt; tags in de juiste volgorde staan.&lt;/p&gt;
&lt;h3&gt;5. Refresh je browser en controleer of alles nog werkt als voorheen. Bekijk tevens de FireBug console en controleer dat er geen errors meer optreden. Bekijk tevens het &quot;Net&quot; tabblad in FireBug en controleer dat alle javascript bestanden worden ingeladen. Wat valt je op?&lt;/h3&gt;
&lt;p&gt;Alle modules worden nog steeds ingeladen, ondanks dat alle &amp;lt;script&amp;gt; tags onderaan de pagina verwijderd zijn. Tevens worden deze in de juiste volgorde ingeladen. De gebruikte AMD implementatie, RequireJS, zorgt hiervoor. RequireJS wordt geinitialiseerd door de enige overgebleven &amp;lt;script&amp;gt; die in de &amp;lt;head&amp;gt; van de pagina staat. Het bestand dat als eerste door RequireJS wordt ingeladen is de module die in het attribuut &quot;data-main&quot; in de &amp;lt;script&amp;gt; tag staat. In dit geval is dat &lt;em&gt;js/init&lt;/em&gt; wat resulteert in dat het bestand &lt;em&gt;js/init.js&lt;/em&gt; zal worden ingeladen.&lt;/p&gt;
&lt;h3&gt;6. Welke taak denk je dat de minification met AMD uitvoert? Naar welke file denk je dat het resultaat zal worden weggeschreven?&lt;/h3&gt;
&lt;p&gt;De &quot;requirejs&quot; taak zorgt voor de minification. Het resultaat wordt naar &quot;target/build-AMD.js&quot; weggeschreven. Als de buildoption &quot;optimize&quot; van waarde &quot;none&quot; naar &quot;uglify&quot; wordt gezet, wordt er trouwens pas echt minification toegepast. Met &quot;none&quot; als waarde zal de &quot;requirejs&quot; taak er alleen voor zorgen dat alle gevonden modules in de outputfile in de juiste volgorde worden geconcateneerd.&lt;/p&gt;
&lt;h3&gt;7. Voer de taak die de minification uitvoert uit en bekijk het resultaat. Wat valt je op aan de gegenereerde outputfile?&lt;/h3&gt;
&lt;p&gt;In de output file, build-AMD.js, staan alle modules in de juiste volgorde achter elkaar.&lt;/p&gt;
&lt;h3&gt;8. Zonder de outputfile worden modules met AMD gevonden in een file die als naam gelijk is aan de modulenaam. Hoe denk je dat RequireJS de modules nu vind?&lt;/h3&gt;
&lt;p&gt;Als je goed kijkt naar de &quot;define&quot; en &quot;require&quot; statements, zie je dat deze nu uit 3 parameters bestaat. De tweede en derde parameters zijn net als voorheen de dependencies die gebruikt worden en de function die de body van de module representeerd. De eerste parameter die in de build-AMD.js bij de &quot;define&quot; en &quot;require&quot; statements staat is echter door het minification proces toegevoegd. Deze parameter geeft de modulenaam weer, die gelijk is aan de bestandslocatie + bestandsnaam minus de extensie &quot;.js&quot; van het bestand waar de module oorspronkelijk voor de minification zich bevond.&lt;/p&gt;
&lt;p&gt;Als deze modulenaam parameter wordt toegevoegd, en er dus van 3 parameters bij &quot;require&quot; en &quot;define&quot; statements gebruik wordt gemaakt, dan weet RequireJS tijdens het laden van de applicatie a.d.v. deze modulenaam, dat er geen daadwerkelijke javascript file hoeft te worden opgehaald. RequireJS zal dan eerst kijken of er reeds een module geladen is met de modulenaam, wat het geval is als alle modules in 1 keer worden ingeladen zoals met het bestand build-AMD.js het geval is.&lt;/p&gt;
]]></content><private><![CDATA[]]></private><author><![CDATA[jsadmin]]></author></item>
